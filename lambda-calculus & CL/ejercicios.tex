\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,top=4cm,bottom=4cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage[spanish]{babel}
\usepackage{libertinus}		
\usepackage{inconsolata}	
\usepackage{amsthm,amsmath,amsfonts,derivative,cancel}
\usepackage{tikz,graphicx,titling,fancyhdr,framed} 
\usepackage{listings}
\usepackage{xcolor}
\usepackage{changepage}
\usepackage{mdframed}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Esto es para los policiclos %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{standalone}
\usepackage{tikz}
\usetikzlibrary{positioning, arrows.meta, shapes.geometric}
\input{polycycle}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcounter{exercise}
\renewcommand{\thesection}{Ejercicio \arabic{exercise}}
\newcommand{\exercise}{%
  \refstepcounter{exercise}%
  \section{}%
}
\newtheorem*{solution}{Solución}

\lstdefinestyle{plaintextstyle}{ 
  basicstyle=\footnotesize,        % Fija el tamaño del tipo de letra utilizado para el código
  breakatwhitespace=false,         % Activarlo para que los saltos automáticos solo se apliquen en los espacios en blanco
  breaklines=true,                 % Activa el salto de línea automático
  captionpos=b,                    % Establece la posición de la leyenda del cuadro de código
  extendedchars=true,              % Permite utilizar caracteres extendidos no-ASCII; solo funciona para codificaciones de 8-bits; para UTF-8 no funciona. En xelatex necesita estar a true para que funcione.
  frame=single,	                   % Añade un marco al código
  keepspaces=true,                 % Mantiene los espacios en el texto. Es útil para mantener la indentación del código(puede necesitar columns=flexible).
  numbers=left,                    % Posición de los números de línea (none, left, right).
  numbersep=10pt,                   % Distancia de los números de línea al código
  numberstyle=\small\color{black}, % Estilo para los números de línea
  rulecolor=\color{black},         % Si no se activa, el color del marco puede cambiar en los saltos de línea entre textos que sea de otro color, por ejemplo, los comentarios, que están en verde en este ejemplo
  showspaces=false,                % Si se activa, muestra los espacios con guiones bajos; sustituye a 'showstringspaces'
  showstringspaces=false,          % subraya solamente los espacios que estén en una cadena de esto
  showtabs=false,                  % muestra las tabulaciones que existan en cadenas de texto con guión bajo
  stepnumber=1,                    % Muestra solamente los números de línea que corresponden a cada salto. En este caso: 1,3,5,...
  tabsize=2,	                   % Establece el salto de las tabulaciones a 2 espacios
  title=\lstname,                  % muestra el nombre de los ficheros incluidos al utilizar \lstinputlisting; también se puede utilizar en el parámetro caption
}

\lstdefinestyle{cppstyle}{ 
  language=C++, 
  basicstyle=\ttfamily\small,       % Fuente monoespaciada pequeña
  keywordstyle=\bfseries\color{teal},        % Palabras clave en azul
  commentstyle=\bfseries.\color{purple},       % Comentarios en verde
  stringstyle=\bfseries\color{olive},          % Cadenas en rojo
  numbers=left,                     % Números de línea a la izquierda
  numberstyle=\tiny\color{black},     % Estilo de los números de línea en rojo
  stepnumber=1,                     % Numerar cada línea
  numbersep=5pt,                    % Separación entre el número y el código
  frame=single,                     % Marco alrededor del código
  backgroundcolor=\color{white},    % Color de fondo blanco
  showstringspaces=false,           % No mostrar espacios en las cadenas
  tabsize=2,                        % Tamaño de tabulación
  breaklines=true,                  % Habilitar la ruptura de líneas largas
  breakatwhitespace=true,           % Romper líneas solo en espacios
  rulecolor=\color{black},         % Si no se activa, el color del marco puede cambiar en los saltos de línea entre textos que sea de otro color, por ejemplo, los comentarios, que están en verde en este ejemplo
  emph={verificar,contenida,equiparar,resolver,log,to_tab,
        combinarEvidencias,juntar_evidencias_hasta,combinarReglaEvidencia,
        juntar_reglas_hasta,anadir_meta,to_decimal},  % Funciones específicas a resaltar
  emphstyle=\bfseries\color{violet}           % Estilo para funciones en violeta
}

\title{Lógica y Programación}
\author{Alejandro Egea López}
\date{\today}

\begin{document}

\pagestyle{fancy}
\setlength{\headheight}{13pt}
\lhead[]{Lógica Y Programación}
\rhead[]{Curso 2025/26}
\cfoot{\rule{\linewidth}{0.4pt} \thepage}

\begin{titlepage} 
	\centering
	\scshape 
	\vspace*{\baselineskip} 
	
	\rule{\textwidth}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt} % Thick horizontal rule
	\rule{\textwidth}{0.4pt}

	\vspace{0.75\baselineskip}
	{\LARGE Lógica Y Programación\\}
	\vspace{0.3\baselineskip} 
	
	\rule{\textwidth}{0.4pt}\vspace*{-\baselineskip}\vspace{3.2pt} % Thin horizontal rule
	\rule{\textwidth}{1.6pt}
	
	\vspace{2\baselineskip}

	{\Large Problemas de $\lambda$-Calculus y Lógica Combinatoria} 
	
	\vspace{1\baselineskip}

	\includegraphics[width=0.5\textwidth]{logo.png}\par
	
	\vspace{2\baselineskip}
	Universidad de Granada\\
	\vspace{0.5\baselineskip}
	{\scshape\Large Lógica Y Programación}
	
	\vspace{2\baselineskip}
	Curso\\
	\vspace{0.5\baselineskip}
	{\scshape\Large 5to curso}

	\vspace{2\baselineskip}
	Docente\\
	\vspace{0.5\baselineskip}
	{\scshape\Large Francisco Miguel García Olmedo}
	
	\vspace{2\baselineskip}
	Autores\\
	\vspace{0.5\baselineskip}
	{\scshape\Large Alejandro Egea López \\ Nicolás Ramírez Rodiles}
	
	\vfill
	A fecha de\\
	\today
\end{titlepage}

\pagebreak

\tableofcontents

\pagebreak
% EJERCICIO 1
\exercise 
\noindent Exponga y desarrolle justificadamente el tema de la ``Notación de de Bruijn''.\\
\begin{solution}
\end{solution}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Introducción}

La notación tradicional del cálculo $\lambda$ usa nombres para las variables ligadas
($x,y,z,\dots$). Esta práctica introduce tres dificultades fundamentales:

\begin{enumerate}
    \item \textbf{Captura accidental}: al sustituir una expresión por una variable libre,
          puede producirse captura si surgen colisiones de nombre con variables ligadas
          en el contexto.
    \item \textbf{Conversión-$\alpha$ obligatoria}: para evitar capturas debe
          renombrarse sistemáticamente las variables ligadas.
    \item \textbf{Complejidad en meta-demostraciones}: propiedades como la
          confluencia o la prueba de Church-Rosser se complican debido a la
          constante necesidad de renombrar.
\end{enumerate}

La propuesta de N.\,G. de Bruijn consiste en \emph{eliminar los nombres de variables
ligadas} y reemplazarlos por \textbf{índices naturales} que indican cuántos ligadores
separan la ocurrencia de su $\lambda$ correspondiente. De este modo:

\begin{itemize}
    \item desaparece por completo la conversión-$\alpha$,
    \item no hay colisiones de nombres,
    \item las definiciones de sustitución, reducción $\beta$ y $\eta$ se vuelven
          puramente estructurales,
    \item las demostraciones metateóricas se simplifican sustancialmente.
\end{itemize}

\noindent El propio de Bruijn establece tres criterios para evaluar una notación:
\begin{enumerate}
    \item[(i)] legibilidad humana,
    \item[(ii)] claridad en discusión metalingüística,
    \item[(iii)] utilidad para implementaciones automáticas.
\end{enumerate}
La notación de índices sacrifica parcialmente el punto (i), pero destaca en (ii) y (iii).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Name-carrying expressions y árbol sintáctico}

Antes de eliminar nombres, representamos aplicaciones mediante un símbolo especial:
\[
A((M),(N)),
\]
que corresponde a la aplicación usual $MN$. Esto permite un análisis uniforme de la estructura.

Consideremos ahora la siguiente expresión $\lambda$-cálculo (tomada del ejemplo del artículo):

\[
\boxed{
\lambda x\ a(\lambda b(x,t,f(\lambda u\ a(u,t,z),\ \lambda s\ w)),w,y)
}
\]

En forma estructurada ``name-carrying’’, cada rama del árbol lleva etiquetas $a,b,f$
según la construcción.

El artículo presenta el siguiente \textbf{árbol anotado} con \emph{reference depth} y
\emph{level}. Los pares $(d,\ell)$ representan:

\begin{itemize}
    \item $d =$ \emph{reference depth}: número de ligadores $\lambda$ desde la
          ocurrencia hasta su ligador,
    \item $\ell =$ \emph{level}: número total de $\lambda$ hasta la raíz.
\end{itemize}

\begin{center}
\includegraphics[width=0.35\textwidth]{tree.png}\par  
\end{center}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Lectura precisa del árbol}

Tomemos algunos nodos para ejemplificar:

\begin{itemize}
    \item El nodo $x$ tiene etiqueta $(2,2)$:
        \begin{itemize}
            \item reference depth $=2$: está bajo dos $\lambda$ antes de llegar a su
                  ligador original \(\lambda_x\),
            \item level $=2$: desde la ocurrencia hasta la raíz hay dos $\lambda$.
        \end{itemize}
    \item El nodo $t$ bajo $b(x,t)$ tiene $(1,2)$:
        \begin{itemize}
            \item depth = 1: está inmediatamente bajo $\lambda_t$,
            \item level = 2: hay dos ligadores superiores en total.
        \end{itemize}
    \item El nodo $v$ etiquetado $(3,1)$ indica que:
        \begin{itemize}
            \item depth = 3: su ligador está tres $\lambda$ más arriba,
            \item level = 1: solo un $\lambda$ separa esa rama de la raíz.
        \end{itemize}
    \item Lo mismo ocurre para $u,t,z,w$ en la rama derecha bajo $f$.
\end{itemize}

Este árbol es la base para convertir la expresión a notación sin nombres.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{De nombres a índices: notación de de Bruijn}

Para cada ocurrencia ligada, sustituimos su nombre por su \emph{reference depth}.

\begin{itemize}
    \item Las variables libres se conservan en una lista ordenada
          $(x_1,x_2,\dots)$,
    \item Los \emph{level} sirven como información auxiliar para verificar la
          corrección formal, pero se omiten en la expresión final.
\end{itemize}

\subsubsection*{Ejemplos simples}

\[
\lambda x.\,x \;\longmapsto\; \lambda.\,1
\]

\[
\lambda x.\,\lambda y.\,(x\,y) \;\longmapsto\; \lambda.\,\lambda.\,(2\,1)
\]

\[
\lambda x.\,\lambda y.\,\lambda z.\,x \;\longmapsto\; \lambda.\,\lambda.\,\lambda.\,3
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Sintaxis de expresiones sin nombres}

Usamos una gramática claramente indentada:

\begin{verbatim}
<NF>         ::= <Const>
               | <Index>
               | <NFList>
               | lambda.<NF>

<Const>      ::= a | b | c | ...         ; constantes simbólicas

<Index>      ::= 1 | 2 | 3 | ...         ; variable ligada por índice

<NFList>     ::= A(<NF>, <NF>)           ; aplicación
               | <NF> <NF>               ; concatenación de expresiones
\end{verbatim}

Esta sintaxis es extremadamente regular: ya no aparecen nombres ligados, sólo índices.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Sustitución en notación de de Bruijn}

La sustitución se define como:

\[
S(Z_1,Z_2,\dots;\; Q),
\]

donde $Z_i$ sustituye a la variable libre cuyo índice es $i$.

Casos fundamentales:

\begin{itemize}
    \item Si $Q$ es una constante, permanece igual.
    \item Si $Q=k$ es un índice, entonces:
          \[
            S(\dots,Z_k;\;k) = Z_k,
          \]
          con ajuste de índices si la sustitución entra bajo una $\lambda$.
    \item Si $Q=A((Q_1),(Q_2))$, entonces:
          \[
             S(Z;\,A((Q_1),(Q_2)))
             = A((S(Z;Q_1)),(S(Z;Q_2))).
          \]
    \item Si $Q=\lambda.\,R$, entonces:
          \[
             S(Z_1,Z_2,\dots;\;\lambda.\,R)
             = \lambda.\,S(Z'_1,Z'_2,\dots;\;R),
          \]
          donde cada $Z'_i$ es la versión de $Z_i$ con sus índices incrementados
          en uno (para preservar referencias correctas).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Reducción $\beta$}

La regla de contracción $\beta$ se expresa elegantemente:

\[
A((\lambda.\,Q),(r))
\;\longrightarrow\;
S(r,2,3,\dots;\;Q),
\]

es decir: sustituimos el índice $1$ por $r$.

\subsubsection*{Ejemplos}

\[
(\lambda x.\,x)\;a
\quad\leadsto\quad
\lambda.\,1\; a
\;\longrightarrow\; a.
\]

\[
(\lambda x.\,\lambda y.\,x)\;y
\quad\leadsto\quad
A((\lambda.\,\lambda.\,2),(y))
\;\longrightarrow\;
\lambda.\,1.
\]

En ningún momento aparece conversión-$\alpha$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Reducción $\eta$}

La regla extensional:

\[
\lambda.\,A((Q),1)\;\longrightarrow\;Q
\]

siempre que $Q$ no contenga ninguna referencia al índice $1$ ligado por la $\lambda$.

Ejemplo:

\[
\lambda x.\,f\,x
\quad\longmapsto\quad
\lambda.\,A((f),1)
\quad\longrightarrow\quad
f.
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Algunos comentarios sobre la reducción múltiple}

De Bruijn desarrolla una teoría de \emph{reducción múltiple} $\beta_U$, donde un conjunto
$U$ de símbolos de aplicación se reduce simultáneamente.

Ideas centrales:

\begin{itemize}
    \item se define la noción de \emph{expresión $U$-correcta},  
    \item la sustitución conserva $U$-corrección (Teorema 10.1),  
    \item la reducción múltiple y la sustitución poseen reglas claras de
          conmutación y composición (Teorema 11.1),  
    \item reducciones múltiples para conjuntos distintos $U,V$ conmutan
          entre sí (Teorema 11.2),  
    \item todo ello conduce a una demostración pulcra del
          \textbf{teorema de Church-Rosser} en la notación sin nombres.
\end{itemize}

En la notación de índices no existe la conversión-$\alpha$ ni conflictos de nombres,
por lo que la demostración se vuelve más transparente: la confluencia se logra por
propiedades puramente estructurales.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Conclusión}

La notación de de Bruijn resuelve de raíz los problemas de captura y renombrado al
sustituir nombres ligados por índices estructurales. La sustitución y la reducción
se vuelven definiciones limpias, algebraicas y mecanizables.  

La aplicación a la reducción múltiple y a la prueba de Church-Rosser muestra que la
notación no sólo simplifica cálculos locales, sino que también clarifica la teoría
global del cálculo $\lambda$.


\pagebreak
% EJERCICIO 2
\exercise 
\noindent Demuestre que para todo $\lambda$-término $N$, \; $\lambda x.x\,K\,N \;\# \; \lambda x.x\,S\,N$. (Nota: Recuérdese que $S\equiv\lambda xyz.xz(yz)$ y $K\equiv\lambda xy.x$).
\begin{solution}
Supongamos, por reducción al absurdo, que $\lambda x.x\,K\,N = \lambda x.x\,S\,N$ y vamos a llegar a la contradicción de que $K=S$, lo cual es imposible porque \( S\#K \) por clase.\\

\noindent En primer lugar, aplicamos la ``regla 3'' con \( Z=K \), de modo que 
\[ \lambda x.x\,K\,N \; = \; \lambda x.x\,S\,N \Rightarrow (\lambda x.x\,K\,N)K \; = \; (\lambda x.x\,S\,N)K \]
Ahora bien, aplicando ``$\beta$-conversión'' y ``sustitución 1'' obtenemos que 
\[ (\lambda x.x\,K\,N)K = KKN \qquad \text{ y } \qquad (\lambda x.x\,S\,N)K = KSN \]
tal que, por transitividad, obtenemos \[ KKN = KSN \]
Finalmente, basta con aplicar la propia definición de K, concluyendo por transitividad que \[ KKN=K \qquad \text{ y } \qquad KSN = S \]
\[ \Rightarrow K=S \]
lo cual es una contradicción.
\end{solution}

\pagebreak
% EJERCICIO 3
\exercise 
\noindent Dibuje razonadamente el grafo $G_\beta(WWW)$, donde $W\equiv\lambda xy.xyy$.
\begin{solution}
Primero, es interesante recordar la definición del grafo de $\beta$-conversión de un $\lambda$-término tal que 

\begin{mdframed}[linewidth=1pt, backgroundcolor=gray!10, roundcorner=5pt]
El grafo de $\beta$-conversión de un $\lambda$-término T (o grafo de reducción de un $\lambda$-término T), que denotaremos por \( G_\beta(T) \), verifica:
\begin{enumerate}
  \item Un $\lambda$-término $M$ es un nodo de \( G_\beta(T) \) si \( \lambda \vdash T = M  \). 
  \item Si \( M_1,M_2 \) son nodos distintos de \( G_\beta(T) \), entonces \( M_1 \not\equiv M_2 \) (en particular, admite \( M_1 =_\beta M_2 \)).
  \item \( n\geq 1 \) aristas unen nodo \( M_1 \) a nodo \( M_2 \) (pudiendo ser \( M_1 \equiv M_2 \)) si, y solo si, \( \lambda \vdash M_1 = M_2 \)
\end{enumerate}
\end{mdframed}

\end{solution}

\pagebreak
% EJERCICIO 4
\exercise 
\noindent Encuentre razonadamente un $\lambda$-término $M$ tal que $G_\beta(M)$ sea exactamente:

\begin{solution}
Sea el candidato \( M \equiv NNI \) donde \[ N \equiv \lambda xy.yyyxxy \qquad\text{e}\qquad I \equiv \lambda x.x \] y veamos que \( G_\beta(M) \) es el grafo del enunciado. Sabiendo que \( II \equiv (\lambda x.x)I = I \), tenemos que
\begin{align*}
  NNI & \equiv (\lambda xy.yyyxxy)NI \\
  & = (\lambda y.yyyNNy)I \\
  & = IIINNI \\ 
  & = IINNI \\
  & = INNI \\
  & = NNI \qquad\text{(¡hemos cerrado el ciclo!)}  
\end{align*} 
En efecto, tenemos cinco $\lambda$-términos no iguales (en el sentido de $\equiv$). Y \( G_\beta(M) \) es

\begin{center}
\polycycle[5]{
  $\mathrm{NNI}$,
  $(\lambda y.yyyNNy)I$,
  $IIINNI$,
  $IINNI$,
  $INNI$
}
\end{center}

Vamos a explorar un poco más este $\lambda$-término que hemos propuesto. Presentamos las siguientes definiciones: 
\[ N_k = \lambda xy.\underbrace{y \cdots y}_{\text{k veces}}xxy \qquad\text{y}\qquad C_{k+2}=N_k N_k I \qquad\text{para } k \in \mathbb{N} \]

Así pues, estas definiciones nos conducen a plantear el siguiente lema.

\begin{mdframed}[linewidth=1pt, backgroundcolor=gray!10, roundcorner=5pt]
  \begin{center}
    \( G_\beta(C_{k+2}) \) es un grafo de reducción cíclico de \( k+2 \) nodos para todo \( k \in \mathbb{N} \).
  \end{center}
\end{mdframed}

Por una parte, veamos el caso base \( k=0 \) tal que \( N_0=\lambda xy.xxy \) y por ende, \( C_2=N_0 N_0 I \). Tras la primera parte del ejercicio, es inmediato comprobar que \( (\lambda y.N_0 N_0 y)I = N_0 N_0 I \) se trata de \( G_\beta(C_2) \) cíclico de 2 nodos. Cabe destacar que el caso base constituye un caso \textit{degenerado}, puesto que \textit{un ciclo de dos nodos no es más que el segmento que los une}.

\begin{center}
\polycycleShort[2]{
  $\mathrm{N_0N_0I}$,
  $(\lambda y.N_0N_0y)I$
}
\end{center}
\end{solution}

Por otra parte, veamos el caso para un $k>0$ arbitrario tal que \( N_k = \lambda xy.\underbrace{y \cdots y}_{\text{k veces}}xxy \), es decir
\begin{align*}
  C_{k+2} = N_k N_k I = (\lambda xy.\underbrace{y \cdots y}_{\text{k veces}}xxy) N_k I & = \\
  & =  (\lambda y.\underbrace{y \cdots y}_{\text{k veces}}N_kN_ky) I \\
  & = \underbrace{I \cdots I}_{\text{k veces}}N_kN_k I \\
  & = \underbrace{I \cdots I}_{\text{k-1 veces}}N_kN_k I \\
  & = \dots \\
  & = I N_kN_k I \\
  & = N_kN_kI
\end{align*}

En conclusión, es inmediato observar que hay \( k+2 \) $\lambda$-términos no iguales (en el sentido de $\equiv$) y así podemos hacer que \( G_\beta(C_{k+2}) \) sea un policiclo de cualquier número \textbf{finito} de nodos mayor o igual que 2.

\begin{center}
\polycycle[5]{
  $\mathrm{N_kN_kI}$,
  $(\lambda y.\underbrace{y \cdots y}_{\text{k veces}}N_kN_ky) I$,
  $\underbrace{I \cdots I}_{\text{k veces}}N_kN_k I$,
  $\dots$,
  $I N_kN_k I$
}
\end{center}

\pagebreak
% EJERCICIO 5
\exercise 
\noindent Sea el $\lambda$-término: \[ G \equiv \lambda yx.x(yx) \qquad\text{y}\qquad M \equiv (\lambda xy.y(xxy))(\lambda xy.y(xxy)).\]
\begin{enumerate}
\item Demuestre que $M$ es un punto fijo de $G$.
\item Demuestre que si el combinador $N$ es un punto fijo de $G$, entonces $N$ es un operador de punto fijo.
\item Demuestre que $M$ es un combinador de punto fijo.
\item Demuestre que si $M$ es un combinador de punto fijo, entonces $M = GM$.
\end{enumerate}
\begin{solution}
\mbox{} \\

\textbf{(1)} Si aplicamos el Teorema del Punto Fijo al $\lambda$-término G, sean $y$ tal que \( y \notin FV(G) \), \( W=\lambda z.G(zz) \) y \( X=WW \), entonces obtenemos que \( X = M \) es punto fijo de $G$. En efecto, 
\begin{align*}
  X & \equiv \\
  & \equiv WW \\
  & = (\lambda yx.x(yyx))(\lambda yx.x(yyx)) \qquad\text{por $(\dagger)$}\\
  & \equiv (\lambda xy.y(xxy))(\lambda xy.y(xxy)) \qquad\text{por $\alpha$-congruencia}
\end{align*}
donde \((\dagger)\) resulta por
\begin{align*}
  W & \equiv \\
  & \equiv \lambda y.G(yy) \\
  & \equiv \lambda y.(\lambda yx.x(yx))(yy) \\
  & = {\beta} \lambda y.((\lambda x.x(yx))[y:=yy]) \qquad\text{por $\beta$-conversión}\\
  & \equiv \lambda y.\lambda x.x(yyx) \qquad\text{por sustitución (1)}\\
  & = \lambda yx.x(yyx)
\end{align*}

\textbf{(2)} Supongamos que el combinador $N$ es un punto fijo de $G$, es decir, \( N = GN \). Por esto,
\begin{align*}
  N & = \\
  & = GN \\
  &\equiv (\lambda yx.x(yx))N \\
  &= \lambda x.((x(yx))[y:=N]) \qquad\text{por $\beta$-conversión}\\
  &\equiv \lambda x.x(Nx) \qquad\text{por sustitución 1}\\
\end{align*}
Y concluimos que, dado $F$ un $\lambda$-término,
\begin{align*}
  NF & = \\
  & = (\lambda x.x(Nx))F \\
  & = (x(Nx))[x:=F] \qquad\text{por $\beta$-conversión}\\
  & = F(NF) \qquad\text{por sustitución 1}
\end{align*}
que es precisamente lo que se quería demostrar. \\

\textbf{(3)} Vamos a presentar una forma inmediata de resolver el ejercicio y otra más didáctica.

Por una parte, $M$ es claramente un combinador porque ninguna variable ocurra libre y, además, es punto fijo de $G$ por el apartado (1). Tenemos que verifica las hipótesis del apartado (2) y por tanto, $M$ es un operador (o combinador) de punto fijo. 

Por otra parte, si denotamos por \( W:=\lambda xy.y(xxy) \) tenemos que 
\begin{align*}
  M & = \\
  & \equiv WW \\
  & \equiv (\lambda xy.y(xxy))W \\
  & = \lambda y.((y(xxy))[x:=W]) \qquad\text{por $\beta$-conversión}\\
  & \equiv \lambda y.y(WWy) \qquad\text{por sustitución 1}\\
  & \equiv \lambda y.y(My) \qquad\text{denotamos por \((\dagger)\)}
\end{align*}
Y llegamos a que, dado $F$ un $\lambda$-término,
\begin{align*}
  MF & = \\
  & = (\lambda y.y(My))F \qquad\text{por \((\ddagger)\)}\\
  & = (y(My))[y:=F] \qquad\text{por $\beta$-conversión}\\
  & \equiv F(MF)  \qquad\text{por sustitución 1}\\
\end{align*}
es decir, que $M$ es un combinador de punto fijo.\\

\textbf{(4)} Supongamos que $N$ es un combinador de punto fijo, es decir, para todo $F$ $\lambda$-término \( NF=F(NF) \). Tomando el $G$ del enunciado tenemos que 
\begin{align*}
  GM & = \\
  & \equiv (\lambda yx.x(yx))N \\
  & = \lambda x.((x(yx))[y:=N]) \qquad\text{por $\beta$-conversión}\\
  & \equiv \lambda x.x(Nx)  \qquad\text{por sustitución 1}\\
\end{align*}

Ahora bien, si tomamos \( T=GN \) llegamos a que
\begin{align*}
  TF = \\
  & = GNF \qquad\text{por regla 3}\\
  & = (\lambda x.x(Nx))F \\
  & = (x(Nx))[x:=F] \qquad\text{por $\beta$-conversión}\\
  & = F(NF) \qquad\text{por sustitución 1}\\
\end{align*}
Finalmente, aplicamos la hipótesis obteniendo que \( TF=F(NF)=NF \), y de nuevo, por la regla 3, tenemos que \( T=N \).

Como partíamos de que \( T=GN \), efectivamente llegamos a que \( N=GN \), es decir, $N$ es punto fijo de $G$.

\end{solution}


\pagebreak
% EJERCICIO 6
\exercise 
\noindent Considere el combinador:
\[ Y\equiv \lambda y.(\lambda x.y(xx))(\lambda x.y(xx)) \]
y demuestre que $GY = Y$.
\begin{solution}

\end{solution}

\pagebreak
% EJERCICIO 7
\exercise 
\noindent Considere la sucesión de combinadores $\{Y^n\}_n$ definida para todo número natural $n$ como sigue:
\[ Y^n = \begin{cases} Y, &\text{si } n=0, \\ Y^{n-1}G, &\text{si } n>0. \end{cases} \]
Demuestre que para todo $n\ge 0$, $Y^n$ es un combinador de punto fijo.
\begin{solution}

\end{solution}

\pagebreak
% EJERCICIO 8
\exercise 
\noindent Encuentre razonadamente el CL-término $(\lambda xy.xyy)_{CL}$.
\begin{solution}
En primer lugar, escribimos el $\lambda$-término como un CL-término de tipo `[x].M' (que usaremos solo permitir la conversión $\lambda \to CL$, pero que no es un CL-término en sí mismo):
\[ (\lambda xy.xyy)_{CL} \to [xy].xyy, \]
y, por definición de abstracción de múltiples variables, obtenemos que 
\[ [xy].xyy \equiv [x]([y].xyy) \]
de modo que ya podemos proceder a aplicar las reglas de abstracción (a), (b), (c), (f) (las que se requieran). A modo de recordatorio:

\begin{mdframed}[linewidth=1pt, backgroundcolor=gray!10, roundcorner=5pt]
\textbf{Definition 2.18 (Abstraction).}
Para todo término de CL llamémoslo $M$ y toda variable $x$, se define por inducción un término de CL llamado $[x].M$ del siguiente modo:
\begin{enumerate}
  \item[(a)] $[x].M \equiv K M$ si $x \notin FV(M)$.
  \item[(b)] $[x].x \equiv I$.
  \item[(c)] $[x].Ux \equiv U$ si $x \notin FV(U)$.
  \item[(f)] $[x].UV \equiv S([x].U)([x].V)$ si no se aplica ninguna de las reglas anteriores.
\end{enumerate}
*Cabe destacar que la referencia prescinde de las reglas (d) y (e); y que en [x].UV usando la regla (f), V es siempre la parte derecha de la aplicación más externa del término.
\end{mdframed}
Vamos a operar según las reglas (*las reglas se enuncian en orden de aplicación):
\begin{align*}
  [x].([y].xyy) & \equiv \\
  & \equiv [x].(S([y].xy)([y].y))  \qquad\text{por regla (f)}\\
  & \equiv [x].(S(S([y].x)([y].y))I)  \qquad\text{por regla (f) y (b)}\\
  & \equiv [x].(S(S(Kx)(I))I)  \qquad\text{por regla (a) y (b)}\\
  & \equiv S([x].S(S(Kx)(I)))([x].I)  \qquad\text{por regla (f)}\\
  & \equiv S(S([x].S)([x].(S(Kx)(I))))KI  \qquad\text{por regla (f) y (a)}\\
  & \equiv S(S(KS)([x].(S(Kx)(I))))KI  \qquad\text{por regla (a) y (f)}\\
  & \equiv S(S(KS)(S([x].S(Kx))([x].I)))KI  \qquad\text{por regla (f)}\\
  & \equiv S(S(KS)(S(S([x].S)([x].Kx))KI))KI  \qquad\text{por regla (f) y (a)}\\
  & \equiv S(S(KS)(S(S(KS)K)KI))KI  \qquad\text{por regla (a) y (c)}\\
\end{align*}

Y por último, podemos aplicar las propias definiciones de los combinadores S, K, I para simplificar la expresión tal que
\begin{align*}
  S(S(KS)(S(S(KS)K)KI))KI & \equiv \\
  & \equiv \text{FALTA TERMINAR ESTA SIMPLIFACIÓN}
\end{align*}


\end{solution}

\pagebreak
% EJERCICIO 9
\exercise 
\noindent Esquematice la relación entre el sistema $\lambda$ y la lógica combinatoria.
\begin{solution}

\end{solution}




\pagebreak

\begin{thebibliography}{9}

\bibitem{deBruijn1972}
De Bruijn, N. G. (1972).
\textit{Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the Church–Rosser theorem}.
\textit{Indagationes Mathematicae (Proceedings), 75}(5), 381--392.
https://doi.org/10.1016/1385-7258(72)90034-0

\bibitem{venturini1984-reduction}
Venturini Zilli, M. (1984).
\textit{Reduction graphs in the lambda calculus}.
\textit{Theoretical Computer Science, 29}(3), 251--275.
https://doi.org/10.1016/0304-3975(84)90002-1

\bibitem{hindley2008-cl}
Hindley, J. R., \& Seldin, J. P. (2008).
\textit{Lambda-calculus and combinators: An introduction} (2nd ed.).
Cambridge University Press.
(Secciones relevantes: Section 2C, \textit{Abstraction in CL}, pp.~26--29; Chapter 9, \textit{Correspondence between $\lambda$ and CL}, pp.~92--106.)

\end{thebibliography}


\end{document}
